{"ast":null,"code":"function _instanceof(left, right) {\n  return null != right && \"undefined\" != typeof Symbol && right[Symbol.hasInstance] ? right[Symbol.hasInstance](left) : left instanceof right;\n}\n\nfunction _typeof(obj) {\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!_instanceof(instance, Constructor)) throw new TypeError(\"Cannot call a class as a function\");\n}\n\nfunction _defineProperties(target, props) {\n  for (var descriptor, i = 0; i < props.length; i++) {\n    descriptor = props[i], descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, \"value\" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  return call && (\"object\" === _typeof(call) || \"function\" == typeof call) ? call : _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (void 0 === self) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (\"function\" != typeof superClass && null !== superClass) throw new TypeError(\"Super expression must either be null or a function\");\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: !0,\n      configurable: !0\n    }\n  }), superClass && _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  return _setPrototypeOf = Object.setPrototypeOf || function (o, p) {\n    return o.__proto__ = p, o;\n  }, _setPrototypeOf(o, p);\n}\n\nimport assert from \"../assert\";\nimport TransitionInterpolator from \"./transition-interpolator\";\nimport { isValid, lerp, getEndValueByShortestPath } from \"./transition-utils\";\n\nvar VIEWPORT_TRANSITION_PROPS = [\"longitude\", \"latitude\", \"zoom\", \"bearing\", \"pitch\"],\n    LinearInterpolator = function (_TransitionInterpolat) {\n  function LinearInterpolator() {\n    var _this,\n        transitionProps = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : VIEWPORT_TRANSITION_PROPS;\n\n    return _classCallCheck(this, LinearInterpolator), _this = _possibleConstructorReturn(this, (LinearInterpolator.__proto__ || Object.getPrototypeOf(LinearInterpolator)).call(this)), _this.propNames = transitionProps, _this;\n  }\n\n  return _inherits(LinearInterpolator, _TransitionInterpolat), _createClass(LinearInterpolator, [{\n    key: \"initializeProps\",\n    value: function initializeProps(startProps, endProps) {\n      var startViewportProps = {},\n          endViewportProps = {},\n          _iteratorNormalCompletion = !0,\n          _didIteratorError = !1,\n          _iteratorError = void 0;\n\n      try {\n        for (var _step, _iterator = this.propNames[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {\n          var key = _step.value,\n              startValue = startProps[key],\n              endValue = endProps[key];\n          assert(isValid(startValue) && isValid(endValue), \"\".concat(key, \" must be supplied for transition\")), startViewportProps[key] = startValue, endViewportProps[key] = getEndValueByShortestPath(key, startValue, endValue);\n        }\n      } catch (err) {\n        _didIteratorError = !0, _iteratorError = err;\n      } finally {\n        try {\n          _iteratorNormalCompletion || null == _iterator.return || _iterator.return();\n        } finally {\n          if (_didIteratorError) throw _iteratorError;\n        }\n      }\n\n      return {\n        start: startViewportProps,\n        end: endViewportProps\n      };\n    }\n  }, {\n    key: \"interpolateProps\",\n    value: function interpolateProps(startProps, endProps, t) {\n      var viewport = {},\n          _iteratorNormalCompletion2 = !0,\n          _didIteratorError2 = !1,\n          _iteratorError2 = void 0;\n\n      try {\n        for (var _step2, key, _iterator2 = this.propNames[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = !0) {\n          key = _step2.value, viewport[key] = lerp(startProps[key], endProps[key], t);\n        }\n      } catch (err) {\n        _didIteratorError2 = !0, _iteratorError2 = err;\n      } finally {\n        try {\n          _iteratorNormalCompletion2 || null == _iterator2.return || _iterator2.return();\n        } finally {\n          if (_didIteratorError2) throw _iteratorError2;\n        }\n      }\n\n      return viewport;\n    }\n  }]), LinearInterpolator;\n}(TransitionInterpolator);\n\nexport { LinearInterpolator as default };","map":null,"metadata":{},"sourceType":"module"}